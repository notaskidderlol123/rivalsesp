local settings = {
    NameColor = Color3.fromRGB(255, 0, 0),
    BoxColor = Color3.fromRGB(255, 0, 0),
    BoneColor = Color3.fromRGB(0, 255, 0),
    LineThickness = 2,
    Transparency = 1,
    DistanceColor = Color3.fromRGB(255, 255, 255),
    DistanceSize = 15,
    AutoScale = true
}

local Space = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Camera = Space.CurrentCamera

-- Function to create lines
local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = settings.Transparency
    return line
end

-- Function to create text
local function NewText(color, size, transparency)
    local text = Drawing.new("Text")
    text.Visible = false
    text.Text = ""
    text.Position = Vector2.new(0, 0)
    text.Color = color
    text.Size = size
    text.Center = true
    text.Transparency = transparency
    return text
end

-- Function to create a box (for the player)
local function NewBox(color, thickness)
    local box = Drawing.new("Line")
    box.Visible = false
    box.Color = color
    box.Thickness = thickness
    return box
end

-- Function to set visibility of the lines
local function Vis(lib, state)
    for i, v in pairs(lib) do
        v.Visible = state
    end
end

-- Function to draw bones
local function DrawBones(plr)
    repeat wait() until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil
    local Library = {}

    -- Create bone connections
    local function createBoneLines()
        local lines = {}
        local bonePairs = {
            {"Head", "Torso"},
            {"Torso", "LeftLeg"},
            {"Torso", "RightLeg"},
            {"Torso", "LeftArm"},
            {"Torso", "RightArm"},
            {"LeftLeg", "LeftFoot"},
            {"RightLeg", "RightFoot"}
        }

        for _, pair in pairs(bonePairs) do
            lines[pair[1] .. "-" .. pair[2]] = NewLine(settings.BoneColor, settings.LineThickness)
        end

        return lines
    end

    local bones = createBoneLines()

    -- Loop to update bone lines
    local function Updater()
        local c
        c = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)
                if vis then
                    for _, line in pairs(bones) do
                        line.Visible = true
                    end

                    -- Update the lines to connect the bones
                    for _, pair in pairs(bones) do
                        local fromPart = Hum:FindFirstChild(pair[1])
                        local toPart = Hum:FindFirstChild(pair[2])

                        if fromPart and toPart then
                            local fromPos, fromVis = Camera:WorldToViewportPoint(fromPart.Position)
                            local toPos, toVis = Camera:WorldToViewportPoint(toPart.Position)

                            if fromVis and toVis then
                                pair.From = Vector2.new(fromPos.X, fromPos.Y)
                                pair.To = Vector2.new(toPos.X, toPos.Y)
                            else
                                pair.Visible = false
                            end
                        end
                    end
                else
                    for _, line in pairs(bones) do
                        line.Visible = false
                    end
                end
            else
                for _, line in pairs(bones) do
                    line.Visible = false
                end
                if game:GetService("Players"):FindFirstChild(plr.Name) == nil then
                    c:Disconnect()
                end
            end
        end)
    end

    coroutine.wrap(Updater)()
end

-- Function to draw tracers
local function DrawTracer(plr, tracerLine)
    local HumanoidRootPart = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if HumanoidRootPart then
        local position, onScreen = Camera:WorldToViewportPoint(HumanoidRootPart.Position)
        if onScreen then
            tracerLine.Visible = true
            tracerLine.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 1.25)
            tracerLine.To = Vector2.new(position.X, position.Y)
        else
            tracerLine.Visible = false
        end
    end
end

-- Function to handle ESP for player names, distance, etc.
local function HandleESP(plr)
    repeat wait() until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil

    local Library = {
        name = NewText(settings.NameColor, settings.Size, settings.Transparency),
        distance = NewText(settings.DistanceColor, settings.DistanceSize, settings.Transparency),
        tracer = NewLine(settings.BoxColor, settings.LineThickness),
        boxTL1 = NewBox(settings.BoxColor, settings.LineThickness),
        boxTL2 = NewBox(settings.BoxColor, settings.LineThickness),
        boxTR1 = NewBox(settings.BoxColor, settings.LineThickness),
        boxTR2 = NewBox(settings.BoxColor, settings.LineThickness),
        boxBL1 = NewBox(settings.BoxColor, settings.LineThickness),
        boxBL2 = NewBox(settings.BoxColor, settings.LineThickness),
        boxBR1 = NewBox(settings.BoxColor, settings.LineThickness),
        boxBR2 = NewBox(settings.BoxColor, settings.LineThickness)
    }

    local function Updater()
        local c
        c = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)
                if vis then
                    Library.name.Visible = true
                    Library.name.Text = plr.Name
                    Library.name.Position = Vector2.new(HumPos.X, HumPos.Y - 15)

                    local distance = (Camera.CFrame.Position - Hum.HumanoidRootPart.Position).Magnitude
                    Library.distance.Visible = true
                    Library.distance.Text = string.format("%.0f studs", distance)
                    Library.distance.Position = Vector2.new(HumPos.X, HumPos.Y + 15)

                    -- Box calculations
                    local boxSize = Vector3.new(2, 5, 1)
                    local TL = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position + Vector3.new(-boxSize.X, boxSize.Y, 0))
                    local TR = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position + Vector3.new(boxSize.X, boxSize.Y, 0))
                    local BL = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position + Vector3.new(-boxSize.X, -boxSize.Y, 0))
                    local BR = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position + Vector3.new(boxSize.X, -boxSize.Y, 0))

                    Library.boxTL1.From = Vector2.new(TL.X, TL.Y)
                    Library.boxTL1.To = Vector2.new(TL.X, TL.Y)
                    Library.boxTL2.From = Vector2.new(TL.X, TL.Y)
                    Library.boxTL2.To = Vector2.new(TL.X + boxSize.X, TL.Y)

                    Library.boxTR1.From = Vector2.new(TR.X, TR.Y)
                    Library.boxTR1.To = Vector2.new(TR.X, TR.Y + boxSize.Y)
                    Library.boxTR2.From = Vector2.new(TR.X, TR.Y)
                    Library.boxTR2.To = Vector2.new(TR.X - boxSize.X, TR.Y)

                    Library.boxBL1.From = Vector2.new(BL.X, BL.Y)
                    Library.boxBL1.To = Vector2.new(BL.X, BL.Y)
                    Library.boxBL2.From = Vector2.new(BL.X, BL.Y)
                    Library.boxBL2.To = Vector2.new(BL.X + boxSize.X, BL.Y)

                    Library.boxBR1.From = Vector2.new(BR.X, BR.Y)
                    Library.boxBR1.To = Vector2.new(BR.X, BR.Y + boxSize.Y)
                    Library.boxBR2.From = Vector2.new(BR.X, BR.Y)
                    Library.boxBR2.To = Vector2.new(BR.X - boxSize.X, BR.Y)

                    -- Tracer
                    DrawTracer(plr, Library.tracer)
                else
                    Library.name.Visible = false
                    Library.distance.Visible = false
                end
            else
                for _, v in pairs(Library) do
                    v.Visible = false
                end
                if game:GetService("Players"):FindFirstChild(plr.Name) == nil then
                    c:Disconnect()
                end
            end
        end)
    end

    coroutine.wrap(Updater)()
end

-- Main loop for existing players and new players
for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= Player.Name then
        coroutine.wrap(HandleESP)(v)
        coroutine.wrap(DrawBones)(v)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(newplr)
    coroutine.wrap(HandleESP)(newplr)
    coroutine.wrap(DrawBones)(newplr)
end)
